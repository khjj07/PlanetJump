local DefRX= require "DefUtil.DefRX.DefRX"
local defgraph = require("defgraph.defgraph")
local STATE={
	float=hash("float"),
	stand=hash("stand"),
	dead=hash("dead")
}
local ROTATE_SCALING = 30

go.property("jumpforce", 4000)
go.property("play", false)

local function draw_line(from, to,color)
	color=color or vmath.vector4(1,0,0,1)
	--msg.post("@render:", "draw_line", { start_point = from, end_point = to, color = color })
end
local function jump(self)
	local planet_pos = go.get_position(self.parent_planet)
	self.flag_parent=self.parent_planet
	self.parent_planet=nil
	go.set_parent(".",self.parent_planet,true)
	local jump_direction = vmath.normalize(go.get_world_position()-planet_pos)
	self.vel=self.vel+jump_direction*self.jumpforce+self.rotate_vel
	DefRX.notify("jump", {position=go.get_world_position()})
	msg.post("#sprite", "play_animation",{id=hash("player_jump")})
	timer.delay(0.3, false, function()
		if self.state==STATE.stand then
			self.state=STATE.float
		end
		msg.post("#sprite", "play_animation",{id=hash("player_idle")})
	end)
end

local function land(self,message)
	self.float_handler=nil
	self.state=STATE.stand
	self.gravity=vmath.vector3()
	self.vel=vmath.vector3()
	self.parent_planet=message.other_id
	local planet_pos = go.get_position(self.parent_planet)
	local normal = vmath.normalize(go.get_position()-planet_pos)
	local rot = vmath.quat_from_to(vmath.vector3(0,1,0), normal)
	go.set_position(go.get_position()+message.distance*normal)
	go.set_rotation(rot)
	go.set_parent(".",self.parent_planet,true)
	DefRX.notify("landing", {position=planet_pos})
end

function apply_gravity_force(self, message_id, message, sender)
	if self.state == STATE.float then
		self.vel=self.vel+message.force
	end
	self.rotate_vel = message.rotate_vel*ROTATE_SCALING
	--debugging
	if self.parent_planet then
		local planet_pos = go.get_position(self.parent_planet)
		local jump_direction = vmath.normalize(go.get_world_position()-planet_pos)
		draw_line(go.get_world_position(), go.get_world_position()+jump_direction*self.jumpforce+self.rotate_vel)
	end
end
local function dead(self, message_id, message, sender)
	DefRX.cancel_all_observing(self)
	self.state=STATE.dead
	self.vel=vmath.vector3()
	particlefx.play("#player_dead")
	go.delete_all(self.ids)
end

local function initialize(self, message_id, message, sender)
	self.play=true
end

local function pause_time(self, message_id, message, sender)
	msg.post(".", "release_input_focus")
end

local function play_time(self, message_id, message, sender)
	msg.post(".", "acquire_input_focus")
end
local function on_gui(self, message_id, message, sender)
	self.on_gui=message.value
end

local function flag_up(self, message_id, message, sender)
	local flag = factory.create("#flag",go.get_world_position()+message.dist_vector)
	go.set_parent(flag,self.flag_parent,true)
	msg.post(self.flag_parent, "flag",{id=flag})
	self.flag_parent=nil
end

function init(self)
	DefRX.create_stream("gravity")
	DefRX.observe(self, "gravity", apply_gravity_force)
	DefRX.create_stream("flag_up")
	DefRX.observe(self, "flag_up", flag_up)
	DefRX.create_stream("game_start")
	DefRX.observe(self, "game_start", initialize)
	DefRX.create_stream("player_dead")
	DefRX.observe(self, "player_dead", dead)
	DefRX.create_stream("pause_time")
	DefRX.observe(self, "pause_time",pause_time)
	DefRX.create_stream("play_time")
	DefRX.observe(self, "play_time",play_time)
	DefRX.create_stream("on_gui")
	DefRX.observe(self, "on_gui",on_gui)
	self.vel=vmath.vector3()
	self.gravity=vmath.vector3()
	self.parent_planet=nil
	self.state=STATE.float
	self.on_gui=false
	self.ids={"player","player_trail"}
	msg.post(".", "acquire_input_focus")
end

function update(self,dt)
	if self.state == STATE.float then
		if vmath.length(self.vel)>0 and not self.rotation_fix then
			local rot = vmath.quat_from_to(vmath.vector3(0,1,0), vmath.normalize(self.vel))
			go.set_rotation(rot)
			DefRX.notify("floating", {position=go.get_position()})
			DefRX.notify("spawn_planet", {position=go.get_world_position()})
		end
	end
	local pos = go.get_position()+self.vel*dt
	--debugging
	draw_line(go.get_world_position(),go.get_world_position()+self.vel*dt*10,vmath.vector4(1,1,0,1))
	go.set_position(pos)
	if self.play then
		DefRX.notify("player_position", {position=go.get_world_position()})
	end
end

function on_message(self, message_id, message, sender)
	DefRX.on_message(self, message_id, message, sender)
	if message_id==hash("contact_point_response") then
		if message.other_group==hash("planet") and self.state==STATE.float then
			land(self,message)
		end
		if message.other_group==hash("satellite") and self.state==STATE.float then
			
		end
	end
	if message_id==hash("trigger_response") then
		if message.enter and vmath.length(self.gravity)>0 then
			local rot = vmath.quat_from_to(vmath.vector3(0,1,0), vmath.normalize(self.gravity))
			go.animate(".", "rotation",go.PLAYBACK_ONCE_FORWARD, rot, go.EASING_LINEAR, 0.1)
		elseif not message.enter then
			self.state=STATE.float
		end
	end
	if message_id==hash("hit") then
		if self.state ~= STATE.dead then
			DefRX.notify("game_over",{position=go.get_world_position()})
			DefRX.notify("player_dead")
		end
	end	
end

function final(self)
	DefRX.cancel_all_observing(self)
end

function on_input(self, action_id, action)
	if not self.on_gui and self.play and action_id==hash("touch") and action.pressed and self.state==STATE.stand then
		jump(self)
	end
end