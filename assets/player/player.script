local DefRX= require "DefUtil.DefRX.DefRX"
local defgraph = require("defgraph.defgraph")
local STATE={
	float=hash("float"),
	stand=hash("stand")
}
local ROTATE_SCALING = 50
go.property("jumpforce", 3000)
go.property("play", false)
local function draw_line(from, to,color)
	color=color or vmath.vector4(1,0,0,1)
	--msg.post("@render:", "draw_line", { start_point = from, end_point = to, color = color })
end
local function jump(self)
	local planet_pos = go.get_position(self.parent_planet)
	self.parent_planet=nil
	go.set_parent(".",self.parent_planet,true)
	local jump_direction = vmath.normalize(go.get_world_position()-planet_pos)
	self.vel=self.vel+jump_direction*self.jumpforce+self.rotate_vel
	DefRX.notify("spawn_planet", {position=go.get_world_position()+jump_direction*self.jumpforce})
	DefRX.notify("jump", {position=go.get_world_position()})
end

local function land(self,message)
	self.float_handler=nil
	self.state=STATE.stand
	self.gravity=vmath.vector3()
	self.vel=vmath.vector3()
	self.parent_planet=message.other_id
	local planet_pos = go.get_position(self.parent_planet)
	local normal = vmath.normalize(go.get_position()-planet_pos)
	local rot = vmath.quat_from_to(vmath.vector3(0,1,0), normal)
	go.set_position(go.get_position()+message.distance*normal)
	go.set_rotation(rot)
	go.set_parent(".",self.parent_planet,true)
	DefRX.notify("landing", {position=planet_pos})
end

function apply_gravity_force(self, message_id, message, sender)
	if self.state == STATE.float then
		self.vel=self.vel+message.force
	end
	self.rotate_vel = message.rotate_vel*ROTATE_SCALING
	--debugging
	if self.parent_planet then
		local planet_pos = go.get_position(self.parent_planet)
		local jump_direction = vmath.normalize(go.get_world_position()-planet_pos)
		draw_line(go.get_world_position(), go.get_world_position()+jump_direction*self.jumpforce+self.rotate_vel)
	end
end

local function initialize(self, message_id, message, sender)
	self.play=true
end

function init(self)
	DefRX.create_stream("gravity")
	DefRX.observe(self, "gravity", apply_gravity_force)
	DefRX.create_stream("game_start")
	DefRX.observe(self, "game_start", initialize)
	
	self.vel=vmath.vector3()
	self.gravity=vmath.vector3()
	self.parent_planet=nil
	self.state=STATE.float
	msg.post(".", "acquire_input_focus")
end

function update(self,dt)
	if self.state == STATE.float then
		if vmath.length(self.vel)>0 and not self.rotation_fix then
			local rot = vmath.quat_from_to(vmath.vector3(0,1,0), vmath.normalize(self.vel))
			go.set_rotation(rot)
		end
		DefRX.notify("floating", {position=go.get_position()})
		DefRX.notify("spawn_planet", {position=go.get_world_position()})
	end
	local pos = go.get_position()+self.vel*dt
	--debugging
	draw_line(go.get_world_position(),go.get_world_position()+self.vel*dt*10,vmath.vector4(1,1,0,1))
	go.set_position(pos)
	DefRX.notify("player_position", {position=go.get_world_position()})
end

function on_message(self, message_id, message, sender)
	DefRX.on_message(self, message_id, message, sender)
	if message_id==hash("contact_point_response") then
		if message.other_group==hash("ground") and self.state==STATE.float then
			land(self,message)
		end
	end
	if message_id==hash("trigger_response") then
		if message.enter and vmath.length(self.gravity)>0 then
			local rot = vmath.quat_from_to(vmath.vector3(0,1,0), vmath.normalize(self.gravity))
			go.animate(".", "rotation",go.PLAYBACK_ONCE_FORWARD, rot, go.EASING_LINEAR, 0.1)
		elseif not message.enter then
			self.state=STATE.float
		end
	end
end

function on_input(self, action_id, action)
	if self.play and action_id==hash("touch") and action.pressed and self.state==STATE.stand then
		jump(self)
	end
end